// http://un7fgo.gengen.ru (C) 2018
// 
// Скетч КСВ-метра и переключателя антенн "в одном флаконе"
// Первоначально скетч написан для связки Arduino Nano + LED&KEY module
// Модуль имеет в своем составе:
// - восемь семисегментных индикаторов
// - восемь светодиодов
// - восемь кнопок
// 
// Для переключения собственно антенных цепей, предполагается эксплуатация совместно с модулями реле.
//
// Кнопки № 1-6 выделены для управления антеннами
// Индикация включенной антенны возложена на соответствующий светодиод.
// 
// Кнопка № 7 служит для отключения всех антенн, т.е. на всех управляющих выходах будет низкий уровень сигнала.
// Светодиод № 7 отвечат за сигнализацию этого режима работы
// 
// Кнопка № 8 отвечает за включение/выключение звукового сигнала о превышении КСВ установленного предела.
// Включение режима звукового сопровождения подтверждается светодиодом № 8.
// 
// На семисегментный индикатор возложена функция отображения текущей мощности и КСВ.
// - первые 4 цифры отображают текущую мощность
// - вторые 4 цифры отображают КСВ
// 
// При трехкратном нажатии одной и той-же кнопки выбора антенны, включается отладочный режим.
// В этом режиме на индикаторах отображаются данные считываемые непосредственно с аналоговых входов Arduino.
// В отладочном режиме мигает светодиод текущей антенны.
// Выход из отладочного режима производится нажатием кнопки № 8.
// Отладочный режим необходим для "калибровки" измерителя мощности и КСВ.
// Исходя из фактически получаемых данных мы можем корректно вычислить коэфициенты для расчета мощности.
// Мощность расчитывается квадратичной функцией Y = A*x*x + B*x + C,
// поскольку на входе мы измеряем напряжение, а мошность пропорциональна квадрату напряжения - P = U*U/R .
// Остальные коэфициенты служат для корректировки нелинейности наших цепей измерения.
// 
// ---------------------------------------------
// Подключаем библиотеки 
#include <TM1638.h>
  
// ---------------------------------------------
// глобальные константы

// контакты используемые для модуля LED & KEY
#define LK_STB 4
#define LK_CLK 3
#define LK_DIO 2

// создаем объект для модуля управления и отображения
TM1638 sk_module = { TM1638(LK_DIO, LK_CLK, LK_STB, true , 0) };

// контакты для считывания показаний прямой и отраженной мощности
#define POW_PIN A1
#define REF_PIN A2

// контакт для подключения звукоизлучающего устройства
#define AUDIO_PIN 13
// частота звукового сигнала
#define AUDIO_FREQUENCY 800
// значение КСВ, при превышении которого начинает подаваться звуковой сигнал
#define SWR_MAX 3

// параметры усреднения считываемых показаний
// количество считываний, для расчета среднего
#define AVG_COUNT 5
// задержка между считываниями показаний датчика, для усреднения, в миллисекундах
#define AVG_TIME 20

// ---------------------------------------------
// глобальные переменные для работы программы

// переменные для считывания и усреднения показаний с датчика
  int PW;
  int RF;

// Предполагаем прараболическую зависимость подводимой мошности от измеряемого нами напряжения
// Расчетные коэфициенты для уравнений типа P = A*X*X + B*X + C
// Коэфициенты уравнения для Прямой мощности
  float PA = 0.0000001;
  float PB = 1.0000001;
  float PC = 0.0000001;
// Коэфициенты уравнения для Обратной мощности
  float RA = 0.0000001;
  float RB = 1.0000001;
  float RC = 0.0000001;

// Переменные для расчета мощностей и КСВ
  float POW;
  float REF;
  float SWR;

// Выводы Arduino для коммутации антенн, всего 6, указываем в удобном нам порядке 
  byte Ant[6] = {5, 6, 7, 8, 9, 10};
// сигналы для включения/выключения реле, нужны при использовании релейных модулей с реверсивным управлением
  int RELAY_ON = HIGH;
  int RELAY_OFF = LOW;


// переменная для текущего режима работы  
// от 0 до 5 - выбор текущей антенны, 6 - все антенны отключены
  int current_mode;
  int old_mode;

// переменная наличия звукового сигнала
  bool sound_on;

// переменная для включения режима "отладки"
  int debug_count;
 
// временные переменные
  String S1;
  String S2;
  int bl;
  float PWr;
  float RFr;

// ---------------------------------------------
// Процедура инициализации
void setup()
{

// определяем режим работы выводом для управления антенными реле
  for (int i=0; i <= 5; i++) {
      pinMode(Ant[i], OUTPUT);  
  }
// выключаем все антенны
  for (int i=0; i <= 5; i++) {
      digitalWrite(Ant[i], LOW);
  }
  
// определяем режим работы аналоговых выводов  
  pinMode(POW_PIN,INPUT);
  pinMode(REF_PIN,INPUT);
  
// по умолчанию включаем "беззвучный" режим
  sound_on = false;
  sk_module.setLED(0, 7);

// включенная антенна по умолчанию
  current_mode = 6;
  old_mode = 0;

// 
  debug_count = 0;

// прочие переменные 
  bl = 1;
  SWR = 1.05;
}

// ---------------------------------------------
// Основное тело программы
void loop()  // цикл
{

// если нужно переключить антенну  
  if (current_mode != old_mode) {
// выключаем все антенны
    for (int i=0; i <= 5; i++) {
        digitalWrite(Ant[i], RELAY_OFF);
    }
// зажигаем соответствующий режиму работы светодиод
    for (int i=0; i <= 6; i++) {
       if ( i == current_mode ) {
          sk_module.setLED(1, i);
       } else {
          sk_module.setLED(0, i);
       }
    }  
// включаем текущую антенну (если есть что включать)
  for (int i=0; i <= 5; i++) {
      if (i == current_mode) { 
        digitalWrite(Ant[i], RELAY_ON);
      }
    }
    old_mode = current_mode;
    debug_count = 0;
    delay(300);
  }

// опрашиваем кнопки
  byte buttons = sk_module.getButtons();
// нажатием кнопок переключаем режим работы нашего устройства
  if (buttons != 0) {
    switch (buttons) {
      case 1 : 
        current_mode = 0;
        debug_count++;
        break;
      case 2 : 
        current_mode = 1;
        debug_count++;
        break;
      case 4 : 
        current_mode = 2;
        debug_count++;
        break;
      case 8 : 
        current_mode = 3;
        debug_count++;
        break;
      case 16 : 
        current_mode = 4;
        debug_count++;
        break;
      case 32: 
        current_mode = 5;
        debug_count++;
        break;
      case 64 : 
        current_mode = 6;
        debug_count++;
        break;
      case 128 : 
        // включение - выключение звукового оповещения
        if (sound_on) {
          sound_on = false;
          sk_module.setLED(0, 7);
          noTone(AUDIO_PIN);
        } else {
          sound_on = true;
          sk_module.setLED(1, 7);
        }
        delay(300);
        break;
    }
  }

        // если нажали 3 раза подряд, то переходим в "отладочный" режим
        if(debug_count >= 3) {
          sk_module.setDisplayToString("-DEBUG- ");
          delay(2000);
          while (debug_count >= 3) {
            // опрашиваем кнопки
            byte buttons = sk_module.getButtons();
            // при нажатии на 8 кнопку выходим из отладочного режима
            if (buttons != 0) {
              switch (buttons) {
                case 128 : 
                debug_count = 0;
                break;
              }
            }
            // считываем данные с аналоговых входов
            PW = analogRead(POW_PIN);
            RF = analogRead(REF_PIN);
            // формируем текстовую строку и выводим на индикатор
            S1 = String(PW);
            while (S1.length()<4){
              S1 = S1 + " " ; 
            }
            S2 = String(RF);  
            while (S2.length()<4){
              S2 = " " + S2 ; 
            }
            sk_module.setDisplayToString(S1+S2);
            // "мигаем" светодиодом, для индикации отладочного режима
            bl = abs(bl-1);
            sk_module.setLED(bl, current_mode);
            delay(100);
            
          }
        // "зажигаем" светодиод режима, из которого перешли в отладочный режим
        sk_module.setLED(1, current_mode);
        }

// считываем показания с датчика и усредняем
  PW = 0;
  RF = 0;
  for (int i=1; i <= AVG_COUNT; i++) {
    PW = PW + analogRead(POW_PIN);
    RF = RF + analogRead(REF_PIN);
    delay(AVG_TIME);
  }
  PW = PW / AVG_COUNT;
  RF = RF / AVG_COUNT;
  // пересчитываем считанные показания в реальную мощность
  POW = PA*PW*PW + PB*PW + PC;
  if (POW < 0) {
    POW = 0;
  }
  
  // пересчитываем считанные показания в реальную мощность
  REF = RA*RF*RF + RB*RF + RC;

  // Поскольку входное напряжение у нас не нормировано 
  // т.е. никто не настраивал с высокой точностью его соответствие между каналами
  // а для расчета КСВ используется напряжение, то мы его получим расчетным путем
  // исходя из того, что при расчете измеряемой мощности у нас учтены все нелинейности каждого канала измерения
  PWr = sqrt(POW * 50);
  RFr = sqrt(REF * 50);
  
  // вычисляем КСВ
  SWR = (PWr + RFr)/(PWr - RFr); 
  // чтобы не пугать нас при отключенном передатчике, КСВ присваивем 1.0
  if ( POW <=0 ) {
    SWR = 1.00;
  }
  // чтобы не пугать нас при "непонятном" КСВ менее 1, КСВ присваивем 0.99
  // это может получиться при перепутывании контактов датчика
  if (SWR < 1 || POW <=0 ) {
    SWR = 0.99;
  }
  // чтобы не "пугаться" большим цифрам, все что больще 30, будет показываться как 29.9
  if (SWR > 30) {
    SWR = 29.9;
  }

  // формируем строку со значение мощности для последующего отображения
  S1 = String(int(POW));
  while (S1.length()<4){
    S1 = S1 + " " ; 
  }

  // если КСВ меньше 10, то можно показывать две цифры после запятой, 
  // а вот если КСВ выше 10, то показываем толкьо одну цифру после запятой
  // тем самым для показаний КСВ у нас всегда выделено три знака
  if (SWR<10) {
    // формируем строку для двух знаков после запятой и выводим на индикатор
    S2 = String(round(SWR*100));  
    while (S2.length()<4){
      S2 = " " + S2 ; 
    }
    sk_module.setDisplayToString(S1+S2,4);
  } else {
    // формируем строку для одного знака после запятой и выводим на индикатор
    S2 = String(round(SWR*10));  
    while (S2.length()<4){
      S2 = " " + S2 ; 
    }
    sk_module.setDisplayToString(S1+S2,2);
  }

// при превышении КСВ заданного значения включаем звуковой сигнал
  if (sound_on) {
    if (SWR > SWR_MAX) {
      tone(AUDIO_PIN, AUDIO_FREQUENCY);
    } else {
      noTone(AUDIO_PIN);
    }
   }
 
}

